import React, { useState, useCallback, useMemo } from 'react';
import { 
  CheckCircle, Download, Search, Menu, RefreshCw
} from 'lucide-react';
import useTheme from '../../hooks/useTheme';
import ThemeToggle from '../shared/ThemeToggle';
import BurgerMenu from './BurgerMenu';
import { useTransactionStore } from '../../hooks/useTransactionStore';
import { 
  normalizeMerchantName, 
  isCreditCardPayment, 
  calculateConfidence 
} from '../../utils/transactionHelpers';

// Import all the sub-components
import CSVUpload from './CSVUpload';
import QuickColumnMapping from './QuickColumnMapping';
import ManualTransactionEntry from './ManualTransactionEntry';
import TransactionSplitter from './TransactionSplitter';
import TransactionReview from './TransactionReview';

const TransactionImport = ({ onNavigate }) => {
  const { isDarkMode } = useTheme();
  const [currentStep, setCurrentStep] = useState('upload');
  const [isProcessing, setIsProcessing] = useState(false);
  const [fileName, setFileName] = useState('');
  const [rawCsvData, setRawCsvData] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [menuOpen, setMenuOpen] = useState(false);
  const [splittingTransaction, setSplittingTransaction] = useState(null);
  
  const {
    transactions,
    setTransactions,
    categories,
    setCategories,
    importHistory,
    setImportHistory,
    duplicateStrategy,
    setDuplicateStrategy
  } = useTransactionStore();

  // Handle menu actions
  const handleMenuAction = (actionId) => {
    setMenuOpen(false);
    
    switch (actionId) {
      case 'import':
        // Already on import page, just close menu
        break;
      case 'dashboard':
        onNavigate('dashboard');
        break;
      case 'start-next-period':
        onNavigate('onboarding');
        break;
      case 'export':
        exportTransactions();
        break;
      default:
        console.log(`Action ${actionId} not implemented`);
    }
  };

  // Suggest category for a transaction
  const suggestCategory = useCallback((description, amount) => {
    const normalizedMerchant = normalizeMerchantName(description);
    
    if (isCreditCardPayment(description)) {
      return categories.find(c => c.id === 'credit-payment') || null;
    }
    
    // Check merchant mappings first
    for (const category of categories) {
      if (category.merchantMappings.has(normalizedMerchant)) {
        return category;
      }
    }
    
    // Fall back to keyword matching
    const desc = description.toLowerCase();
    const categoryScores = categories.map(category => {
      if (!category.keywords) return { category, score: 0 };
      
      const score = category.keywords.reduce((acc, keyword) => {
        if (desc.includes(keyword.toLowerCase())) {
          return acc + keyword.length;
        }
        return acc;
      }, 0);
      
      return { category, score };
    });
    
    const bestMatches = categoryScores
      .filter(({ category, score }) => {
        if (score === 0) return false;
        if (category.type === 'income' && amount <= 0) return false;
        if (category.type === 'expense' && amount >= 0) return false;
        return true;
      })
      .sort((a, b) => b.score - a.score);
    
    if (bestMatches.length > 0) {
      return bestMatches[0].category;
    }
    
    // Default fallback based on amount sign
    if (amount > 0) {
      return categories.find(c => c.type === 'income') || categories[0];
    } else {
      return categories.find(c => c.type === 'expense') || categories[0];
    }
  }, [categories]);

  // Process transactions after CSV mapping
  const processTransactions = useCallback((mappedData) => {
    const existingHashes = new Set(
      transactions.map(t => `${t.date}-${t.amount}-${normalizeMerchantName(t.description)}`)
    );
    
    const processed = mappedData.map((transaction, index) => {
      const amount = parseFloat(transaction.amount) || 0;
      const normalizedDesc = normalizeMerchantName(transaction.description || '');
      const hash = `${transaction.date}-${amount}-${normalizedDesc}`;
      
      const isDuplicate = existingHashes.has(hash);
      const suggestedCategory = suggestCategory(transaction.description || '', amount);
      
      return {
        id: `import-${Date.now()}-${index}`,
        date: transaction.date || new Date().toISOString().split('T')[0],
        description: transaction.description || 'Unknown Transaction',
        normalizedMerchant: normalizedDesc,
        amount: amount,
        category: suggestedCategory,
        confidence: calculateConfidence(transaction.description, suggestedCategory),
        confirmed: false,
        isDuplicate,
        originalData: transaction
      };
    });
    
    // Handle duplicates based on strategy
    let finalTransactions = processed;
    if (duplicateStrategy === 'skip') {
      finalTransactions = processed.filter(t => !t.isDuplicate);
    } else if (duplicateStrategy === 'replace') {
      const nonDuplicateExisting = transactions.filter(t => {
        const hash = `${t.date}-${t.amount}-${t.normalizedMerchant}`;
        return !processed.some(p => hash === `${p.date}-${p.amount}-${p.normalizedMerchant}`);
      });
      setTransactions(nonDuplicateExisting);
    }
    
    setTransactions(prev => [...prev, ...finalTransactions]);
    return finalTransactions;
  }, [transactions, suggestCategory, duplicateStrategy, setTransactions]);

  // Update transaction category and learn from it
  const updateTransactionCategory = useCallback((transactionId, categoryId) => {
    const transaction = transactions.find(t => t.id === transactionId);
    if (!transaction) return;
    
    const newCategory = categories.find(c => c.id === categoryId);
    if (!newCategory) return;
    
    // Update the transaction
    setTransactions(prev => prev.map(t => 
      t.id === transactionId 
        ? { 
            ...t, 
            category: newCategory, 
            confirmed: true,
            confidence: 1.0
          }
        : t
    ));
    
    // Learn the merchant mapping
    const normalizedMerchant = normalizeMerchantName(transaction.description);
    setCategories(prev => prev.map(cat => {
      if (cat.id === categoryId) {
        const updatedMappings = new Map(cat.merchantMappings);
        updatedMappings.set(normalizedMerchant, true);
        return { ...cat, merchantMappings: updatedMappings };
      }
      // Remove from other categories if it was there
      if (cat.merchantMappings.has(normalizedMerchant)) {
        const updatedMappings = new Map(cat.merchantMappings);
        updatedMappings.delete(normalizedMerchant);
        return { ...cat, merchantMappings: updatedMappings };
      }
      return cat;
    }));
  }, [transactions, categories, setTransactions, setCategories]);

  // Confirm all transactions
  const confirmAllTransactions = useCallback(() => {
    const confirmedTransactions = transactions.map(t => ({ ...t, confirmed: true }));
    
    // Add to import history
    setImportHistory(prev => [...prev, {
      id: Date.now(),
      date: new Date().toISOString(),
      fileName: fileName,
      count: transactions.length,
      transactions: confirmedTransactions
    }]);
    
    setTransactions([]);
    setCurrentStep('complete');
    
    return confirmedTransactions;
  }, [transactions, fileName, setImportHistory, setTransactions]);

  // Handle file upload
  const handleFileProcessed = async (csvData, filename) => {
    setIsProcessing(true);
    setFileName(filename);
    try {
      setRawCsvData(csvData);
      setCurrentStep('mapping');
    } catch (error) {
      console.error('Error processing file:', error);
      alert('Error processing file. Please check the format and try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  // Handle column mapping completion
  const handleMappingComplete = async (mappedData) => {
    setIsProcessing(true);
    try {
      await processTransactions(mappedData);
      setCurrentStep('review');
    } catch (error) {
      console.error('Error processing transactions:', error);
      alert('Error processing transactions. Please try again.');
    } finally {
      setIsProcessing(false);
    }
  };

  // Handle transaction splitting
  const handleSplitTransaction = (originalTransactionId, splitTransactions) => {
    setTransactions(prev => {
      const filtered = prev.filter(t => t.id !== originalTransactionId);
      return [...filtered, ...splitTransactions];
    });
    setSplittingTransaction(null);
  };

  // Reset import process
  const resetImport = () => {
    setTransactions([]);
    setRawCsvData([]);
    setCurrentStep('upload');
    setFileName('');
    setSearchQuery('');
    setSplittingTransaction(null);
  };

  // Export transactions to CSV
  const exportTransactions = () => {
    const dataToExport = transactions.map(t => ({
      date: t.date,
      description: t.description,
      amount: t.amount,
      category: t.category?.name || '',
      type: t.category?.type || '',
      confirmed: t.confirmed
    }));
    
    const csv = dataToExport.map(row => 
      Object.values(row).map(v => 
        typeof v === 'string' && v.includes(',') ? `"${v}"` : v
      ).join(',')
    ).join('\n');
    
    const csvWithHeaders = 'date,description,amount,category,type,confirmed\n' + csv;
    
    const blob = new Blob([csvWithHeaders], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `transactions-export-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Filter transactions based on search
  const filteredTransactions = useMemo(() => {
    if (!searchQuery) return transactions;
    
    const query = searchQuery.toLowerCase();
    return transactions.filter(t => 
      t.description.toLowerCase().includes(query) ||
      t.category?.name.toLowerCase().includes(query) ||
      t.amount.toString().includes(query)
    );
  }, [transactions, searchQuery]);

  return (
    <div className={`min-h-screen transition-colors ${
      isDarkMode ? 'bg-gray-900' : 'bg-gray-50'
    }`}>
      {/* Unified Burger Menu */}
      <BurgerMenu 
        isOpen={menuOpen}
        onClose={() => setMenuOpen(false)}
        onAction={handleMenuAction}
        currentPage="import"
      />

      {/* Transaction Splitter Modal */}
      {splittingTransaction && (
        <TransactionSplitter
          transaction={splittingTransaction}
          categories={categories}
          onSplit={handleSplitTransaction}
          onCancel={() => setSplittingTransaction(null)}
        />
      )}

      {/* Header */}
      <div className={`border-b ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`}>
        <div className="max-w-6xl mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button
                onClick={() => setMenuOpen(true)}
                className={`p-2 rounded-lg transition-colors ${
                  isDarkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-100'
                }`}
              >
                <Menu className="w-6 h-6" />
              </button>
              <div>
                <h1 className={`text-2xl font-bold ${isDarkMode ? 'text-white' : 'text-gray-900'}`}>
                  Import Transactions
                </h1>
                {fileName && (
                  <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                    Processing: {fileName}
                  </p>
                )}
              </div>
            </div>
            <ThemeToggle />
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="max-w-6xl mx-auto p-6 space-y-6">
        {/* Progress Indicator */}
        <div className="text-center mb-8">
          <div className="flex items-center justify-center gap-2">
            {['upload', 'mapping', 'review', 'complete'].map((step, index) => (
              <React.Fragment key={step}>
                <div className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium transition-all ${
                  currentStep === step 
                    ? 'bg-blue-500 text-white ring-4 ring-blue-200' 
                    : ['upload', 'mapping', 'review', 'complete'].indexOf(currentStep) > index 
                      ? 'bg-green-500 text-white' 
                      : isDarkMode ? 'bg-gray-700 text-gray-400' : 'bg-gray-200 text-gray-500'
                }`}>
                  {['upload', 'mapping', 'review', 'complete'].indexOf(currentStep) > index ? (
                    <CheckCircle className="w-5 h-5" />
                  ) : (
                    index + 1
                  )}
                </div>
                {index < 3 && (
                  <div className={`w-8 h-1 transition-all ${
                    ['upload', 'mapping', 'review', 'complete'].indexOf(currentStep) > index 
                      ? 'bg-green-500' 
                      : isDarkMode ? 'bg-gray-700' : 'bg-gray-200'
                  }`} />
                )}
              </React.Fragment>
            ))}
          </div>
          <div className="mt-4">
            <p className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
              {currentStep === 'upload' && 'Upload your CSV file or add transactions manually'}
              {currentStep === 'mapping' && 'Map your CSV columns to transaction fields'}
              {currentStep === 'review' && 'Review and categorize your transactions'}
              {currentStep === 'complete' && 'Import completed successfully!'}
            </p>
          </div>
        </div>

        {/* Step Content */}
        {currentStep === 'upload' && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div>
              <CSVUpload onFileProcessed={handleFileProcessed} isProcessing={isProcessing} />
              
              {/* Duplicate Strategy Settings */}
              <div className={`mt-4 p-4 rounded-lg ${isDarkMode ? 'bg-gray-800' : 'bg-gray-50'}`}>
                <h4 className={`text-sm font-medium mb-2 ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>
                  Duplicate Handling
                </h4>
                <div className="space-y-2">
                  {[
                    { value: 'skip', label: 'Skip duplicates (recommended)' },
                    { value: 'replace', label: 'Replace existing' },
                    { value: 'keep-both', label: 'Keep both' }
                  ].map(option => (
                    <label key={option.value} className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="radio"
                        value={option.value}
                        checked={duplicateStrategy === option.value}
                        onChange={(e) => setDuplicateStrategy(e.target.value)}
                        className="text-blue-500"
                      />
                      <span className={`text-sm ${isDarkMode ? 'text-gray-300' : 'text-gray-700'}`}>
                        {option.label}
                      </span>
                    </label>
                  ))}
                </div>
              </div>
            </div>
            
            <div>
              <ManualTransactionEntry 
                categories={categories} 
                onAddTransaction={(t) => {
                  setTransactions(prev => [...prev, t]);
                  if (currentStep === 'upload') {
                    setCurrentStep('review');
                  }
                }}
              />
            </div>
          </div>
        )}

        {currentStep === 'mapping' && (
          <QuickColumnMapping
            csvData={rawCsvData}
            onMappingComplete={handleMappingComplete}
            onCancel={() => setCurrentStep('upload')}
          />
        )}

        {currentStep === 'review' && (
          <div className="space-y-4">
            {/* Search and Export Controls */}
            <div className={`rounded-lg p-4 shadow-sm ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
              <div className="flex flex-wrap gap-4 items-center justify-between">
                <div className="flex gap-2 flex-1">
                  <div className="relative flex-1 max-w-md">
                    <Search className="absolute left-3 top-2.5 w-4 h-4 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search transactions..."
                      value={searchQuery}
                      onChange={(e) => setSearchQuery(e.target.value)}
                      className={`w-full pl-10 pr-3 py-2 border rounded-lg ${
                        isDarkMode 
                          ? 'border-gray-600 bg-gray-700 text-gray-100 placeholder-gray-400' 
                          : 'border-gray-300 bg-white text-gray-900 placeholder-gray-500'
                      }`}
                    />
                  </div>
                  <button
                    onClick={exportTransactions}
                    disabled={transactions.length === 0}
                    className={`px-4 py-2 border rounded-lg transition-colors flex items-center gap-2 ${
                      transactions.length > 0
                        ? isDarkMode 
                          ? 'border-gray-600 text-gray-300 hover:bg-gray-700' 
                          : 'border-gray-300 text-gray-700 hover:bg-gray-50'
                        : isDarkMode 
                          ? 'border-gray-700 text-gray-500 cursor-not-allowed' 
                          : 'border-gray-200 text-gray-400 cursor-not-allowed'
                    }`}
                  >
                    <Download className="w-4 h-4" />
                    Export
                  </button>
                </div>
              </div>
            </div>
            
            <TransactionReview
              transactions={filteredTransactions}
              categories={categories}
              onCategoryChange={updateTransactionCategory}
              onConfirm={confirmAllTransactions}
              onSplitTransaction={setSplittingTransaction}
            />
          </div>
        )}

        {currentStep === 'complete' && (
          <div className="text-center space-y-6">
            <div className={`rounded-xl p-8 ${
              isDarkMode ? 'bg-green-900/20' : 'bg-green-50'
            }`}>
              <CheckCircle className="w-16 h-16 text-green-500 mx-auto mb-4" />
              <h2 className={`text-2xl font-bold mb-2 ${
                isDarkMode ? 'text-green-200' : 'text-green-800'
              }`}>
                Import Complete!
              </h2>
              <p className={isDarkMode ? 'text-green-300' : 'text-green-700'}>
                Successfully imported and categorized your transactions
              </p>
            </div>
            
            {/* Import Statistics */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 max-w-2xl mx-auto">
              <div className={`rounded-lg p-4 shadow-sm ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
                <div className={`text-2xl font-bold ${isDarkMode ? 'text-gray-100' : 'text-gray-900'}`}>
                  {importHistory[importHistory.length - 1]?.count || 0}
                </div>
                <div className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                  Transactions
                </div>
              </div>
              <div className={`rounded-lg p-4 shadow-sm ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
                <div className={`text-2xl font-bold ${isDarkMode ? 'text-gray-100' : 'text-gray-900'}`}>
                  {categories.reduce((acc, cat) => acc + (cat.merchantMappings?.size || 0), 0)}
                </div>
                <div className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                  Learned Merchants
                </div>
              </div>
              <div className={`rounded-lg p-4 shadow-sm ${isDarkMode ? 'bg-gray-800' : 'bg-white'}`}>
                <div className={`text-2xl font-bold ${isDarkMode ? 'text-gray-100' : 'text-gray-900'}`}>
                  {Math.round(
                    (importHistory[importHistory.length - 1]?.transactions.filter(t => t.confidence >= 0.8).length / 
                     importHistory[importHistory.length - 1]?.count || 0) * 100
                  )}%
                </div>
                <div className={`text-sm ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                  Auto-categorized
                </div>
              </div>
            </div>
            
            {/* Action Buttons */}
            <div className="flex gap-4 justify-center">
              <button
                onClick={resetImport}
                className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors flex items-center gap-2"
              >
                <RefreshCw className="w-4 h-4" />
                Import More
              </button>
              <button
                onClick={() => handleMenuAction('dashboard')}
                className={`px-6 py-2 rounded-lg transition-colors ${
                  isDarkMode 
                    ? 'bg-gray-700 text-gray-300 hover:bg-gray-600' 
                    : 'bg-gray-500 text-white hover:bg-gray-600'
                }`}
              >
                View Dashboard
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

